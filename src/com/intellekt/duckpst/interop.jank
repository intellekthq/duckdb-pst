(ns com.intellekt.duckpst.interop)

(cpp/raw "#include <utils.h>")

;(defmacro unbox
;  [boxed]
;  `(let [t-str# (cpp/duckpst.jank.get_box_type_str ~boxed)]
;     (eval `(cpp/cast (cpp/type ~t-str#) (cpp/unbox (cpp/type ~t-str#) ~~boxed)))))

(defmacro ->wstring
  [s]
  `(->> (cpp/cast cpp/std.string (str ~s))
        (cpp/duckpst.wstring.from_utf8)))

(defmacro wstring->string
  [s]
  `(cpp/duckpst.wstring.to_utf8 ~s))

(defmacro unbox-deref
  [type-str boxed]
  `(cpp/* (unbox ~type-str ~boxed)))

(defmacro &box
  [x]
  `(-> ~x (cpp/&) (cpp/box)))

(defmacro unbox
  [type-str boxed]
  `(cpp/unbox (cpp/type ~type-str) ~boxed))

(defmacro nullptr?
  [p]
  `(cpp/cast (cpp/type "bool")
             (cpp/! ~p)))

(defmacro defn-iteratorseq
  "Convenience for defining a function taking two iterators to yield a seq"
  [name pointer-type bindings & body]
  `(defn ~name
     [begin# end#]
     (let [u-current# (unbox-deref ~pointer-type begin#)
           u-end#     (unbox-deref ~pointer-type end#)]
       (when (cpp/!= u-current# u-end#)
         (let [~(last bindings) (-> u-current# (cpp/*) (&box))
               x# (do ~@body)
               next#   (cpp/++ u-current#)]
           (cons x# (~name (&box next#) end#)))))))

(defmacro when-let*
  ([bindings & body]
   (if (seq bindings)
     `(when-let [~(first bindings) ~(second bindings)]
        (when-let* ~(drop 2 bindings) ~@body))
     `(do ~@body))))
